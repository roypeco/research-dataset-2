Violation ID,File Path,Message,Context,Fixed
E226,./asv_bench/benchmarks/io/style.py,E226 missing whitespace around arithmetic operator,"        self.df = DataFrame(
            np.random.randn(rows, cols),
            columns=[f""float_{i+1}"" for i in range(cols)],
            index=[f""row_{i+1}"" for i in range(rows)],
        )
",False
E226,./asv_bench/benchmarks/io/style.py,E226 missing whitespace around arithmetic operator,"            np.random.randn(rows, cols),
            columns=[f""float_{i+1}"" for i in range(cols)],
            index=[f""row_{i+1}"" for i in range(rows)],
        )

",False
F824,./pandas/_config/config.py,F824 `global reset_option` is unused,"    # it does not fit in to this monkey-patching scheme

    global register_option, get_option, set_option, reset_option

    def wrap(func: F) -> F:
",False
E721,./pandas/_config/config.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","
    def inner(x) -> None:
        if type(x) != _type:
            raise ValueError(f""Value must have type '{_type}'"")

",False
E721,./pandas/_testing/asserters.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        return type(x).__name__

    if type(left) == type(right):
        return

",False
E721,./pandas/_testing/asserters.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        isinstance(left, DatetimeLikeArrayMixin)
        and isinstance(right, DatetimeLikeArrayMixin)
        and type(right) == type(left)
    ):
        # Avoid slow object-dtype comparisons
",False
E721,./pandas/core/arrays/_arrow_utils.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","    def __eq__(self, other):
        if isinstance(other, pyarrow.BaseExtensionType):
            return type(self) == type(other) and self.freq == other.freq
        else:
            return NotImplemented
",False
E721,./pandas/core/arrays/_arrow_utils.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","    def __eq__(self, other):
        if isinstance(other, pyarrow.BaseExtensionType):
            return (
                type(self) == type(other)
                and self.subtype == other.subtype
",False
E721,./pandas/core/arrays/base.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","            Whether the arrays are equivalent.
        """"""
        if type(self) != type(other):
            return False
        other = cast(ExtensionArray, other)
",False
E721,./pandas/core/arrays/interval.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","            left = left.astype(right.dtype)

        if type(left) != type(right):
            msg = (
                f""must not have differing left [{type(left).__name__}] and ""
",False
E721,./pandas/core/arrays/interval.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","
    def equals(self, other) -> bool:
        if type(self) != type(other):
            return False

",False
E721,./pandas/core/arrays/masked.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","    @doc(ExtensionArray.equals)
    def equals(self, other) -> bool:
        if type(self) != type(other):
            return False
        if other.dtype != self.dtype:
",False
F824,./pandas/core/computation/expressions.py,F824 `global _TEST_RESULT` is unused,"
def _store_test_result(used_numexpr: bool) -> None:
    global _TEST_RESULT
    if used_numexpr:
        _TEST_RESULT.append(used_numexpr)
",False
E721,./pandas/core/indexes/base.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","                for c in self._comparables
            )
            and type(self) == type(other)
        )

",False
E201,./pandas/core/ops/array_ops.py,E201 whitespace after '{',"        if not is_scalar(y):
            raise TypeError(
                f""Cannot broadcast np.ndarray with operand of type { type(y) }""
            )

",False
E202,./pandas/core/ops/array_ops.py,E202 whitespace before '}',"        if not is_scalar(y):
            raise TypeError(
                f""Cannot broadcast np.ndarray with operand of type { type(y) }""
            )

",False
E226,./pandas/io/excel/_odswriter.py,E226 missing whitespace around arithmetic operator,"        if style_key in self._style_dict:
            return self._style_dict[style_key]
        name = f""pd{len(self._style_dict)+1}""
        self._style_dict[style_key] = name
        odf_style = Style(name=name, family=""table-cell"")
",False
E231,./pandas/io/formats/format.py,E231 missing whitespace after ',"                precision = get_option(""display.precision"")
                float_format = lambda x: _trim_zeros_single_float(
                    f""{x: .{precision:d}f}""
                )
        else:
",False
E226,./pandas/io/formats/style.py,E226 missing whitespace around arithmetic operator,"                    styles.append(
                        {
                            ""selector"": f""thead tr:nth-child({level+1}) th"",
                            ""props"": props
                            + (
",False
E226,./pandas/io/formats/style.py,E226 missing whitespace around arithmetic operator,"                    styles.append(
                        {
                            ""selector"": f""thead tr:nth-child({obj.nlevels+1}) th"",
                            ""props"": props
                            + (
",False
E226,./pandas/io/formats/style.py,E226 missing whitespace around arithmetic operator,"                            ""props"": props
                            + (
                                f""top:{(i+1) * pixel_size}px; height:{pixel_size}px; ""
                                ""z-index:2;""
                            ),
",False
E226,./pandas/io/formats/style.py,E226 missing whitespace around arithmetic operator,"                        [
                            {
                                ""selector"": f""thead tr th:nth-child({level+1})"",
                                ""props"": props_ + ""z-index:3 !important;"",
                            },
",False
E226,./pandas/io/formats/style.py,E226 missing whitespace around arithmetic operator,"            cell_css += ""background: linear-gradient(90deg,""
            if start > 0:
                cell_css += f"" transparent {start*100:.1f}%, {color} {start*100:.1f}%,""
            cell_css += f"" {color} {end*100:.1f}%, transparent {end*100:.1f}%)""
        return cell_css
",False
E226,./pandas/io/formats/style.py,E226 missing whitespace around arithmetic operator,"            cell_css += ""background: linear-gradient(90deg,""
            if start > 0:
                cell_css += f"" transparent {start*100:.1f}%, {color} {start*100:.1f}%,""
            cell_css += f"" {color} {end*100:.1f}%, transparent {end*100:.1f}%)""
        return cell_css
",False
E226,./pandas/io/formats/style.py,E226 missing whitespace around arithmetic operator,"            if start > 0:
                cell_css += f"" transparent {start*100:.1f}%, {color} {start*100:.1f}%,""
            cell_css += f"" {color} {end*100:.1f}%, transparent {end*100:.1f}%)""
        return cell_css

",False
E226,./pandas/io/formats/style.py,E226 missing whitespace around arithmetic operator,"            if start > 0:
                cell_css += f"" transparent {start*100:.1f}%, {color} {start*100:.1f}%,""
            cell_css += f"" {color} {end*100:.1f}%, transparent {end*100:.1f}%)""
        return cell_css

",False
E226,./pandas/io/formats/style_render.py,E226 missing whitespace around arithmetic operator,"            return command, f""[HTML]{{{value[1:].upper()}}}{arg}""
        if value[0] == ""#"" and len(value) == 4:  # color is short hex code
            val = f""{value[1].upper()*2}{value[2].upper()*2}{value[3].upper()*2}""
            return command, f""[HTML]{{{val}}}{arg}""
        elif value[:3] == ""rgb"":  # color is rgb or rgba
",False
E226,./pandas/io/formats/style_render.py,E226 missing whitespace around arithmetic operator,"            return command, f""[HTML]{{{value[1:].upper()}}}{arg}""
        if value[0] == ""#"" and len(value) == 4:  # color is short hex code
            val = f""{value[1].upper()*2}{value[2].upper()*2}{value[3].upper()*2}""
            return command, f""[HTML]{{{val}}}{arg}""
        elif value[:3] == ""rgb"":  # color is rgb or rgba
",False
E226,./pandas/io/formats/style_render.py,E226 missing whitespace around arithmetic operator,"            return command, f""[HTML]{{{value[1:].upper()}}}{arg}""
        if value[0] == ""#"" and len(value) == 4:  # color is short hex code
            val = f""{value[1].upper()*2}{value[2].upper()*2}{value[3].upper()*2}""
            return command, f""[HTML]{{{val}}}{arg}""
        elif value[:3] == ""rgb"":  # color is rgb or rgba
",False
E721,./pandas/io/sql.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        while True:
            data = cursor.fetchmany(chunksize)
            if type(data) == tuple:
                data = list(data)
            if not data:
",False
E501,./pandas/tests/arrays/categorical/test_repr.py,E501 line too long (97 > 88 characters),"
        c = Categorical(idx.append(idx), categories=idx)
        exp = """"""[1 days, 2 days, 3 days, 4 days, 5 days, 1 days, 2 days, 3 days, 4 days, 5 days]
Categories (5, timedelta64[ns]): [1 days, 2 days, 3 days, 4 days, 5 days]""""""

",False
E501,./pandas/tests/arrays/categorical/test_repr.py,E501 line too long (97 > 88 characters),"
        c = Categorical(idx.append(idx), categories=idx, ordered=True)
        exp = """"""[1 days, 2 days, 3 days, 4 days, 5 days, 1 days, 2 days, 3 days, 4 days, 5 days]
Categories (5, timedelta64[ns]): [1 days < 2 days < 3 days < 4 days < 5 days]""""""

",False
E721,./pandas/tests/arrays/integer/test_construction.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        else:
            assert r == e
            assert type(r) == type(e)


",False
E721,./pandas/tests/arrays/interval/test_interval.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","            res = arr.min(skipna=skipna)
            assert res == MIN
            assert type(res) == type(MIN)

            res = arr.max(skipna=skipna)
",False
E721,./pandas/tests/arrays/interval/test_interval.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","            res = arr.max(skipna=skipna)
            assert res == MAX
            assert type(res) == type(MAX)

        res = arr_na.min(skipna=False)
",False
E721,./pandas/tests/arrays/interval/test_interval.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        res = arr_na.min(skipna=True)
        assert res == MIN
        assert type(res) == type(MIN)
        res = arr_na.max(skipna=True)
        assert res == MAX
",False
E721,./pandas/tests/arrays/interval/test_interval.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        res = arr_na.max(skipna=True)
        assert res == MAX
        assert type(res) == type(MAX)


",False
E721,./pandas/tests/arrays/sparse/test_array.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        assert arr.fill_value is False
        arr_expected = np.array(data, dtype=object)
        it = (type(x) == type(y) and x == y for x, y in zip(arr, arr_expected))
        assert np.fromiter(it, dtype=np.bool_).all()

",False
E721,./pandas/tests/arrays/sparse/test_dtype.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","    result = sparse_dtype.fill_value
    if pd.isna(fill_value):
        assert pd.isna(result) and type(result) == type(fill_value)
    else:
        assert result == fill_value
",False
E721,./pandas/tests/extension/base/dim2.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","
        if err_result is not None or err_expected is not None:
            assert type(err_result) == type(err_expected)
            return

",False
E721,./pandas/tests/extension/base/dim2.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","                getattr(data, method)()
            except Exception as err2:
                assert type(err) == type(err2)
                return
            else:
",False
E721,./pandas/tests/extension/base/dim2.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","                    pass
                else:
                    assert type(expected) == type(data), type(expected)
                assert dtype == expected.dtype

",False
E721,./pandas/tests/extension/base/dim2.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","                getattr(data, method)()
            except Exception as err2:
                assert type(err) == type(err2)
                return
            else:
",False
E226,./pandas/tests/extension/base/getitem.py,E226 missing whitespace around arithmetic operator,"                ""Out of bounds access"",  # Sparse
                f""loc must be an integer between -{ub} and {ub}"",  # Sparse
                f""index {ub+1} is out of bounds for axis 0 with size {ub}"",
                f""index -{ub+1} is out of bounds for axis 0 with size {ub}"",
            ]
",False
E226,./pandas/tests/extension/base/getitem.py,E226 missing whitespace around arithmetic operator,"                f""loc must be an integer between -{ub} and {ub}"",  # Sparse
                f""index {ub+1} is out of bounds for axis 0 with size {ub}"",
                f""index -{ub+1} is out of bounds for axis 0 with size {ub}"",
            ]
        )
",False
E721,./pandas/tests/extension/base/interface.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        # the data can never contain other nan-likes than na_value
        for na_value_obj in tm.NULL_OBJECTS:
            if na_value_obj is na_value or type(na_value_obj) == type(na_value):
                # type check for e.g. two instances of Decimal(""NAN"")
                continue
",False
E721,./pandas/tests/extension/base/interface.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        result = data.view()
        assert result is not data
        assert type(result) == type(data)

        result[1] = result[0]
",False
E721,./pandas/tests/extension/base/reshaping.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        # as long as EA is 1D-only, ravel is a no-op
        result = data.ravel()
        assert type(result) == type(data)

        # Check that we have a view, not a copy
",False
E721,./pandas/tests/extension/base/reshaping.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","    def test_transpose(self, data):
        result = data.transpose()
        assert type(result) == type(data)

        # check we get a new object
",False
E741,./pandas/tests/frame/indexing/test_getitem.py,E741 ambiguous variable name 'l',"            Index,
            set,
            lambda l: dict(zip(l, range(len(l)))),
            lambda l: dict(zip(l, range(len(l)))).keys(),
        ],
",False
E741,./pandas/tests/frame/indexing/test_getitem.py,E741 ambiguous variable name 'l',"            set,
            lambda l: dict(zip(l, range(len(l)))),
            lambda l: dict(zip(l, range(len(l)))).keys(),
        ],
        ids=[""list"", ""iter"", ""Index"", ""set"", ""dict"", ""dict_keys""],
",False
E721,./pandas/tests/frame/methods/test_pop.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","
        res = df.pop(""a"")
        assert type(res) == DataFrame
        assert len(res) == 2
        assert len(df.columns) == 1
",False
E226,./pandas/tests/frame/methods/test_set_axis.py,E226 missing whitespace around arithmetic operator,"        msg = (
            f""Length mismatch: Expected axis has {len(obj)} elements, ""
            f""new values have {len(obj)-1} elements""
        )
        with pytest.raises(ValueError, match=msg):
",False
E721,./pandas/tests/frame/test_block_internals.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","            }
        )
        assert type(df[""c""]._mgr.blocks[0]) == ObjectBlock
        assert type(df2[""c""]._mgr.blocks[0]) == ObjectBlock
        tm.assert_frame_equal(df, df2)
",False
E721,./pandas/tests/frame/test_block_internals.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        )
        assert type(df[""c""]._mgr.blocks[0]) == ObjectBlock
        assert type(df2[""c""]._mgr.blocks[0]) == ObjectBlock
        tm.assert_frame_equal(df, df2)

",False
E226,./pandas/tests/groupby/test_categorical.py,E226 missing whitespace around arithmetic operator,"
    df = DataFrame({""value"": np.random.randint(0, 10000, 100)})
    labels = [f""{i} - {i+499}"" for i in range(0, 10000, 500)]
    cat_labels = Categorical(labels, labels)

",False
E501,./pandas/tests/indexes/categorical/test_formats.py,E501 line too long (98 > 88 characters),"        # multiple lines
        idx = CategoricalIndex([""a"", ""bb"", ""ccc""] * 10)
        expected = """"""CategoricalIndex(['a', 'bb', 'ccc', 'a', 'bb', 'ccc', 'a', 'bb', 'ccc', 'a',
                  'bb', 'ccc', 'a', 'bb', 'ccc', 'a', 'bb', 'ccc', 'a', 'bb',
                  'ccc', 'a', 'bb', 'ccc', 'a', 'bb', 'ccc', 'a', 'bb', 'ccc'],
",False
E501,./pandas/tests/indexes/categorical/test_formats.py,E501 line too long (98 > 88 characters),"        # multiple lines
        idx = CategoricalIndex([""あ"", ""いい"", ""ううう""] * 10)
        expected = """"""CategoricalIndex(['あ', 'いい', 'ううう', 'あ', 'いい', 'ううう', 'あ', 'いい', 'ううう', 'あ',
                  'いい', 'ううう', 'あ', 'いい', 'ううう', 'あ', 'いい', 'ううう', 'あ', 'いい',
                  'ううう', 'あ', 'いい', 'ううう', 'あ', 'いい', 'ううう', 'あ', 'いい', 'ううう'],
",False
E501,./pandas/tests/indexes/categorical/test_formats.py,E501 line too long (90 > 88 characters),"            # multiple lines
            idx = CategoricalIndex([""あ"", ""いい"", ""ううう""] * 10)
            expected = """"""CategoricalIndex(['あ', 'いい', 'ううう', 'あ', 'いい', 'ううう', 'あ', 'いい',
                  'ううう', 'あ', 'いい', 'ううう', 'あ', 'いい', 'ううう',
                  'あ', 'いい', 'ううう', 'あ', 'いい', 'ううう', 'あ', 'いい',
",False
E501,./pandas/tests/indexes/multi/test_formats.py,E501 line too long (95 > 88 characters),"        mi = wide_multi_index
        result = mi[:1].__repr__()
        expected = """"""MultiIndex([('a', 9, '2000-01-01 00:00:00', '2000-01-01 00:00:00', ...)],
           names=['a', 'b', 'dti_1', 'dti_2', 'dti_3'])""""""
        assert result == expected
",False
E741,./pandas/tests/io/json/test_readlines.py,E741 ambiguous variable name 'l',"def test_readjson_unicode(monkeypatch):
    with tm.ensure_clean(""test.json"") as path:
        monkeypatch.setattr(""locale.getpreferredencoding"", lambda l: ""cp949"")
        with open(path, ""w"", encoding=""utf-8"") as f:
            f.write('{""£©µÀÆÖÞßéöÿ"":[""АБВГДабвгд가""]}')
",False
E226,./pandas/tests/io/json/test_ujson.py,E226 missing whitespace around arithmetic operator,"        assert extreme_num == ujson.decode(str(extreme_num))

    @pytest.mark.parametrize(""too_extreme_num"", [f""{2**64}"", f""{-2**63-1}""])
    def test_decode_too_extreme_numbers(self, too_extreme_num):
        with pytest.raises(
",False
E226,./pandas/tests/io/json/test_ujson.py,E226 missing whitespace around arithmetic operator,"            ujson.decode(""{}\n\t a"")

    @pytest.mark.parametrize(""value"", [f""{2**64}"", f""{-2**63-1}""])
    def test_decode_array_with_big_int(self, value):
        with pytest.raises(
",False
E226,./pandas/tests/io/parser/test_mangle_dupes.py,E226 missing whitespace around arithmetic operator,"
        for j in range(i + 1):
            col_name = ""Unnamed: 0"" + f"".{1*j}"" * min(j, 1)
            expected.insert(loc=0, column=col_name, value=[0, 1, 2])

",False
E741,./pandas/tests/io/pytables/test_round_trip.py,E741 ambiguous variable name 'l',"        values = np.random.randn(2)

        func = lambda l, r: tm.assert_series_equal(l, r, check_index_type=True)

    with catch_warnings(record=True):
",False
E721,./pandas/tests/io/pytables/test_store.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","            tbl[""a""] = tm.makeDataFrame()
            assert len(tbl) == 1
            assert type(tbl[""a""]) == DataFrame


",False
E721,./pandas/tests/io/pytables/test_store.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        tm.assert_frame_equal(df, df2, check_names=True)

        assert type(df2.index.name) == str
        assert type(df2.columns.name) == str

",False
E721,./pandas/tests/io/pytables/test_store.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","
        assert type(df2.index.name) == str
        assert type(df2.columns.name) == str


",False
E226,./pandas/tests/plotting/test_series.py,E226 missing whitespace around arithmetic operator,"            series.plot.pie, colors=color_args, autopct=""%.2f"", fontsize=7
        )
        pcts = [f""{s*100:.2f}"" for s in series.values / series.sum()]
        expected_texts = list(chain.from_iterable(zip(series.index, pcts)))
        self._check_text_labels(ax.texts, expected_texts)
",False
E721,./pandas/tests/scalar/timestamp/test_arithmetic.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        # Timestamp + datetime not supported, though subtraction is supported
        # and yields timedelta more tests in tseries/base/tests/test_base.py
        assert type(ts - dt) == Timedelta
        assert type(ts + td) == Timestamp
        assert type(ts - td) == Timestamp
",False
E721,./pandas/tests/scalar/timestamp/test_arithmetic.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        # and yields timedelta more tests in tseries/base/tests/test_base.py
        assert type(ts - dt) == Timedelta
        assert type(ts + td) == Timestamp
        assert type(ts - td) == Timestamp

",False
E721,./pandas/tests/scalar/timestamp/test_arithmetic.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        assert type(ts - dt) == Timedelta
        assert type(ts + td) == Timestamp
        assert type(ts - td) == Timestamp

        # Timestamp +/- datetime64 not supported, so not tested (could possibly
",False
E721,./pandas/tests/scalar/timestamp/test_arithmetic.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        # assert error raised?)
        td64 = np.timedelta64(1, ""D"")
        assert type(ts + td64) == Timestamp
        assert type(ts - td64) == Timestamp

",False
E721,./pandas/tests/scalar/timestamp/test_arithmetic.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        td64 = np.timedelta64(1, ""D"")
        assert type(ts + td64) == Timestamp
        assert type(ts - td64) == Timestamp

    @pytest.mark.parametrize(
",False
E721,./pandas/tests/scalar/timestamp/test_timestamp.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        expected = datetime(2000, 1, 1)
        assert result == expected
        assert type(result) == type(expected)

        result = ts.to_datetime64()
",False
E721,./pandas/tests/scalar/timestamp/test_timestamp.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        expected = np.datetime64(ts.value, ""ns"")
        assert result == expected
        assert type(result) == type(expected)
        assert result.dtype == expected.dtype

",False
E721,./pandas/tests/series/indexing/test_setitem.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","
        indexer_sli(ser)[1] = val
        assert type(ser.iloc[1]) == type(val)

        expected = Series([True, val], dtype=object, index=ser.index)
",False
E721,./pandas/tests/series/test_repr.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        index1 = [""\u03c3"", ""\u03c4"", ""\u03c5"", ""\u03c6""]
        df = Series(data, index=index1)
        assert type(df.__repr__() == str)  # both py2 / 3

    def test_repr_max_rows(self):
",False
E721,./pandas/tests/series/test_ufunc.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","            if same_type:
                # check we have e.g. Timestamp instead of dt64
                assert type(result) == type(expected)

    def test_min(self, values_for_np_reduce, box_with_array):
",False
E721,./pandas/tests/series/test_ufunc.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","            if same_type:
                # check we have e.g. Timestamp instead of dt64
                assert type(result) == type(expected)


",False
E721,./pandas/tests/test_common.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","    # GH 35611
    unpickled = tm.round_trip_pickle(obj)
    assert type(obj) == type(unpickled)


",False
E721,./pandas/tests/tslibs/test_conversion.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","
    if err1 is not None:
        assert type(err1) == type(err2)
    else:
        assert err2 is None
",False
E721,./pandas/tseries/holiday.py,"E721 do not compare types, for exact checks use `is` / `is not`, for instance checks use `isinstance()`","        self.end_date = Timestamp(end_date) if end_date is not None else end_date
        self.observance = observance
        assert days_of_week is None or type(days_of_week) == tuple
        self.days_of_week = days_of_week

",False
E122,./scripts/validate_rst_title_capitalization.py,E122 continuation line missing indentation or outdented,"                print(
                    f""""""{filename}:{line_number}:{err_msg} ""{title}"" to ""{
                    correct_title_capitalization(title)}"" """"""
                )
                number_of_errors += 1
",False
